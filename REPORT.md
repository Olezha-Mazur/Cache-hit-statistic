| Лабораторная работа №3 | M3102 | АОВС |
| ---------------------- | ----------- | ---- |
| Кэш и кодирование команд    | Мазур Олег       | 2024 |

## Инструментарий
> C++20

## Что реализовано
> Вариант 2. Была выполнена полная версия работы. В репозитории: код задачи на ассемблере, код задачи, преобразованный в машинный код. Код, порождающий эти файлы.

## Результат работы на тестовых данных: https://github.com/skkv-itmo-comp-arch/se-comp-arch24-cache-isa-Olezha-Mazur/actions/runs/9132443596

# Описание:

## Перевод констант

1. Был выделен объем памяти в 512 Кбайт (MEM_SIZE). Из этого числа находим другую константу ADDR_LEN, отвечающая за длину адреса байта в памяти(log2(MEM_SIZE в байтах) = 19).
2. ADDR_LEN состоит из 3 частей, длины двух изкоторых нам известны - CACHE_OFFSET_LEN, CACHE_INDEX_LEN. Отсюда находим 3ю часть - CACHE_TAG_LEN(19 - 5 - 4 = 10).
3. Нам известна длина смещения внутри линии, поэтому мы можем найти CACHE_LINE_SIZE(2^CACHE_OFFSET_LEN = 32).
4. Зная CACHE_LINE_SIZE и CACHE_SIZE можно найти CACHE_LINE_COUNT(CACHE_SIZE / CACHE_LINE_SIZE = 64).
5. Зная CACHE_INDEX_LEN - число, кодирующее номер блока, можем найти количество блоков CACHE_SETS = 2 ^ CACHE_INDEX_LEN.
6. Найдем оставшуюся константу CACHE_WAY, как CACHE_LINE_COUNT / CACHE_SETS, так как она отвечает за количество кэш-линий в одном блоке.

Все константы найдены!

## Перевод в RISC-V

Для начала мной были записаны в отдельный регистры размеры строк и столбцов матриц(M, N, K). Так же, зная адрес начала 1ой матрицы можно рассчитать ее размер, как M * K, и начало второй матрицы.
Если начало 1ой матрицы лежит по адресу 0x100, то вторая лежит по адресу 0x900. Размер второй матрицы был тоже подсчитан, как (K * N * 2), потому что хранит uint16_t. 
Таким образом было подсчитано начало 3ей матрицы - 0x1800. Далее сохраняем указатели на матрицу А, как адрес начала, в регистр a0, а указательна C в a2. Заводим счетчик внешнег цикла в регистре t0 и счетчик второго в t1. В теле второго цикла заводим s и указатель на B в разных регистрах. Заходим во внутренний цикл.

Устанавливаем в t2 счетчик внутреннего цикла. Заносим в регистр a7 сумму указателя на A и счетчика t2. Получаем адрес нужного байта и вызываем команду lb. В t6 заносим сумму t1 (счетчик второго цикла) c собой, а потом складываем в a6 заносим сумму указателя на B и t6. Так мы получаем в a6 адрес первого байта из нужной нам пары. Читаем их в a6 инструкцией lh. 

Перемножаем регистры a6 и а7 и заносим в t4. Потом t4 прибавляем к s. Сдвигаем указатель на B на 120 (размер стсроки * на 2, потому что 2 байта). Увеличиваем счетчик t2. Проходим цикл K раз, возвращаясь у нужной инструкции инструкцией blt.

Далее находим адрес первого из нужных 4х байтов матрицы C. Умножаем 4, сохраненное в регистр, на счетчик второго цикла и складываем результат с указателем на матрицу C. Записываем в этот адрес командой sw. Увеличиваем счетчик t1 и переходим в начало уже второго цикла инструкцией ```blt	t1, s1, -68```.

Когда выходим тело внешнего цикла, сдвигаем указаль на A на K байтов вперед, а указательна C на N * 4 байтов вперед. Увеличиваем счетчик внешнего цикла и делаем еще один прыжок командой blt в начало внешнего цикла.

В уонце пишем инструкцию ```jalr	zero, ra, 0```, которая означает, что функция отработала, и надо куда-то вернуться, где эту функицю вызвали.

## Устройства Кэша

Мной было реализовано 2 класса. Один **LRUCache**, другой **bit-pLRUCache**. Эти два класса отличаются только входящей в них структурой **Set**, которая эмилирует блок в кэше и реализует конкретную политику вытеснения. В поле у них ветор размера **CACHE_SETS** из структур **Set**, а еще поля **val_try**, отвечающее за количество попаданий в кэш, и **total_**, считающее общее число обращений в кэш.

**store_statistic()**
Выводит отношение **val_try_** к **total_**, которое показывает процент попадания в кэш в формате, заданном в тз.

**Load(uint32_t address)**
Принимает адрес байта, к которому обращаются.
Находится значение тэга строки, по которому мы поймем, попали мы или нет. ```uint16_t tag = (address >> (CACHE_OFFSET_LEN + CACHE_INDEX_LEN));```.
Так же находим значение индекса блока в кэше, как ```uint16_t index = ((address - (tag << (CACHE_OFFSET_LEN + CACHE_INDEX_LEN))) >> (CACHE_OFFSET_LEN));```. Во всей лабароторной эти значения считаются одинаково, поэтому буду это опускать далее. 
Далее в функции инкрементируется **total_** и вызывается функция **load** у блока на месте **index** в массиве блоков. Функция возвраащет пару из була и байта. Еслси *true*, инкрементируем **val_try_**.

**Store(uint32_t address, uint8_t byte)**
Принимает адрес и байт, который нужно вставит по этому адресу. Функция устроена так же, как и **Load**. Только она вызывает функцию **store** конкретного блока. Если функция блока вернула *true*, то инкрементируем **val_try_**.

### SET в LRUCache
Структура блока кэша. Она хранит связный список из пар типа: тэг кэш линии и ее данные в векторе uint8_t - **cacheList**. Также она хранит **cacheMap** std::unordered_map, в которой ключи - тэги хранимых строк, а значение итераторы **cacheList**. Когда линия использовалась, она удаляется из списка и добавляется в начало. Итератор в мапе обновляется. Таким образом будет линия, которую при необходимости надо заместить будет в конце этого списка, так она позже всех использовалась. 

**std::pair<bool, uint8_t> load(uint32_t address)**
Рассчитываем тэг, индекс и смещение по адресу. Проверяем есть ли тэг функцией find. 
1. Если есть, то мы попали в кэш, такая строка уже есть. Удаляем ее из списка и добавляем в начало, меняем итератор в **cacheMap**. Возвращаем пару ииз true и байта в массиве данных кэш линии на месте смещения.
2. Если строка не нашлась и места в блоке уже нет, мы удаляем из списка строку в конце **cacheList**, не забывая занести ее обратно в память по ее адресу.
3. Теперь даже если строка не нашлась, место для нее точно есть. Мы подгружаем строку из памяти по адресу, который передали в функцию и добавляем ее в начало списка, как недавно использованную. Добавляем в мапу тэг и итератаор начала списка. Возвращаем пару из false и байта из подгруженной строки на месте смещения

**bool store(uint32_t address, uint8_t byte)**
Функция по своей работе похожа на **load**. Только тут при нахождении мы будем возвращать *true* И менять значение в массиве данных строки. Если строки нет, возвращаем **false** и меняем значение в подгруженной строке.

### SET в bit-pLRUCache
Реализация отличаается от **LRU**, но имеет функции с тем же, названием, а так же несколько новых. Структура хранит ввектор из других структур **CacheLine**

**CacheLine**
Поля:
1. bool mru - бит использования строки
2. uint32_t tag - тэг строки
3. std::vector<uint8_t> data - байты строки

**std::pair<bool, uint8_t> load(uint32_t address)**
Высчитывается тэг, индекс и смещение.
Далее вызывается функция **Find(tag)**, которая пробегает массив и возвращает индекс, если она есть, иначе -1.
Если строка нашлась, то ее **mru** ставится *true*, а потом, если размер блока достиг **CACHE_WAY**, функцией **Fill** заполняет **mru** **false**, если все *true*, а текущей опять ставит в **true**.
Далее возвращается пара из *true* и байта из массива данных, найденной строки
Если не нашлась, подгружаем строку из памяти функцией **LoadLine**. Далее, если массив не заполнился, добавляем структуру из {true, tag, data} и вызываем **Fill**
Если нет места, ищем первую строку, где ``mru = false``. Ищем функцией **FindFirst** и заменяем на нужную. Проверяем нужен ли **Fill** и возвращаем пару из *false* и нужного байта

**bool store(uint32_t address, uint8_t byte)**
Работает аналогичным образом, только тут значение заменяется на byte. У найденной строки заменяем прям в кэше и выводим *true*. Если не нашли, возвращаем *false* и меняем в подгруженной.


## Memory and registers
Для эмуляции работы процессора был заведен вектор из **memory** размером **MEM_SIZE**.
Также был заведен вектор **reg** размером 32. Для удобства был создан словарь с ключами - строчными названиями регистров, а значениями - индексов в массиве **reg**.

## Чтение инструкций
Изначально создается в глобальной области видимости массив **arr**, состояший из структур **Instruction**.

**Instruction**
Хранит строку - тип инструкции. Поля rd, rs1, rs2, imm, чтобы была одна структура для всех инструкций, потому что разные инструкции делают разное.

**ReadInstructions**
Разбиваем читаемый файл на слова, разделенные пробеламим. Если встретился комментарий мы ставим в хранимый флаг *false*, чтобы эти строки не обновлялись. Когда встретили инуструкцию, возвращаем **true**. Получили вектор строк.
Теперь идем по нему и группируем слова в объекты **Instruction**. Обрабатываем тип передаваемой инструкции, благодаря словарю **types**, в котором кажой инструкции присвоен номер, а так же проставлены классы инструкций. В зависимости от значения в **Instruction** сохраняется значение индекса в массиве **reg**. Инструкция собирается уже в понятной форме: с индексами регистров в массиве **reg** и константами, которые функцией **ToInt** переводятся из строки в число. Даже, если число было передано в 16ричной системе счисления. На выходе из функции получаем заполненный массив **arr**.

**ASM**
функция **ReadInstructions** вызывает именно здесь, после открытия файла на ассемблере. Так же тут в зависимости от аргумента **--replacement** создается либо объект класса **LRUCache**, либо **bit-pLRUCache**, либо оба. А так же вызывается функция **Simulate**, которая исполняет файл на аассемблерее, меняя значения в регистрах

**Simulate**
Создаем поинтер **PC**. Он будет отслеживать, на какой инструкции мы сейчас находимся. Далее идем по маасссиву **arr**, пока не выйдем за его пределы, выполняем. Внутри этот цикл утсроен довольно просто. switch case на 46 вариантов:), каждый под отдельную инструкцию. Информацию о том, как работает каждая инстсрукция я брал в памятке (сслыка в конце). Большинство инструкций пишутся просто. Остановимся на важных для нас. Инструкции lb, lbu, lh, lhu, lw, sb, sh, sw. С lb, lbu, sb - все просто. Вызываем функцию load или store в нашем кэше, но они могут загрузить или сохранить только олин байт. Но в других командах происходит работа с бОлбшим количеством байтов. Здесь мы действуем по правилу: Если все байты, которые затрагивает инструкция, лежат в кэше, то мы засчитываем попадание, иначе промах. Искусственно отнимаем значения у **val_try** и **total**, чтобы симулировалась работа кэша для 2 и 4 байт. 
Инструкции типа B делают прыжок, сдвигая **PC**, на какое-то количство инструкций.

Отлично, просимулировали код на ассемблере и получили отношение попаданий к запросам. Я делал 2 вариант и при **replacemant** 0, у меня получились следующие значения:
LRU     hit rate: 96.6571%
pLRU    hit rate: 96.6406%

## Перевод в машинный код
Для этой обработки была использована одна функция **BIN**, в которой по типу инструкции генерировались 4 байта машинного кода. Для этой обработки был использован массив **arr**, а так же еще несколько словарей: **func7**, **func3**, **opcode**, которые отражают нужные части для кодирования каждой инструкции.

**BIN**
Мы проебгаемся по массиву **arr**, определяем, к какому типу относится инструкция. В зависимости от типа, выбираем в функции нужное ветвление и собираем ее код по кусочкам. Информацию нашел в памятке в интернете https://github.com/jameslzhu/riscv-card/blob/master/riscv-card.pdf. Потом закодированное записываем в файл, заданный через консоль.
